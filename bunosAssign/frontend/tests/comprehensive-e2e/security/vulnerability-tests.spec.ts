import { test, expect } from '@playwright/test'
import { ComprehensiveTestUtils } from '../../utils/comprehensive-test-utils'

/**
 * Security Vulnerability Tests
 * Validates protection against common security threats and vulnerabilities
 */

test.describe('Security Vulnerability Tests', () => {
  let utils: ComprehensiveTestUtils
  let adminToken: string
  let employeeToken: string

  test.beforeAll(async ({ request }) => {
    const page = await request.newContext().then(c => c.newPage())
    utils = new ComprehensiveTestUtils(page, request)
    
    adminToken = await utils.loginAs('admin')
    employeeToken = await utils.loginAs('employee')
    
    await page.close()
  })

  test.describe('XSS (Cross-Site Scripting) Protection', () => {
    test('should sanitize HTML in input fields', async ({ page }) => {
      await utils.loginAs('admin')
      await page.goto('/employees')
      await page.waitForLoadState('networkidle')

      // Click add employee
      await page.click('text=新增员工')

      const xssPayloads = [
        '<script>alert("XSS")</script>',
        '<img src=x onerror=alert("XSS")>',
        '<svg onload=alert("XSS")>',
        'javascript:alert("XSS")',
        '<iframe src="javascript:alert(\'XSS\')"></iframe>',
        '<body onload=alert("XSS")>',
        '<input onfocus=alert("XSS") autofocus>'
      ]

      for (const payload of xssPayloads) {
        // Clear and fill name field with XSS payload
        await page.fill('input[placeholder*="姓名"]', payload)
        
        // Check if any script execution occurred
        const alertFired = await page.evaluate(() => {
          return new Promise<boolean>((resolve) => {
            let alertCalled = false
            const originalAlert = window.alert
            
            window.alert = (message) => {
              alertCalled = true
              originalAlert(message)
            }
            
            setTimeout(() => {
              window.alert = originalAlert
              resolve(alertCalled)
            }, 500)
          })
        })

        expect(alertFired, `XSS payload executed: ${payload}`).toBe(false)

        // Clear field for next test
        await page.fill('input[placeholder*="姓名"]', '')
      }

      // Cancel dialog
      await page.click('text=取消')
    })

    test('should prevent XSS in API responses', async ({ request }) => {
      const xssData = {
        employeeNo: `XSS_${Date.now()}`,
        name: '<script>alert("API_XSS")</script>',
        departmentId: 1,
        positionId: 1,
        annualSalary: 100000,
        entryDate: '2024-01-01'
      }

      const result = await utils.testApiEndpoint('POST', '/api/employees', {
        token: adminToken,
        data: xssData
      })

      if (result.status === 201) {
        const createdEmployee = result.data.data
        
        // Name should be sanitized
        expect(createdEmployee.name).not.toContain('<script>')
        expect(createdEmployee.name).not.toContain('alert')
        expect(createdEmployee.name).not.toContain('javascript:')

        // Clean up
        await utils.testApiEndpoint('DELETE', `/api/employees/${createdEmployee.id}`, {
          token: adminToken
        }).catch(() => {})
      }
    })

    test('should handle XSS in search parameters', async ({ page }) => {
      await utils.loginAs('admin')
      await page.goto('/employees')
      await page.waitForLoadState('networkidle')

      const xssSearchPayloads = [
        '<script>alert("SEARCH_XSS")</script>',
        '\"><script>alert("SEARCH_XSS")</script>',
        'javascript:alert("SEARCH_XSS")'
      ]

      for (const payload of xssSearchPayloads) {
        const searchInput = page.locator('input[placeholder*="搜索"]')
        if (await searchInput.isVisible()) {
          await searchInput.fill(payload)
          await page.keyboard.press('Enter')
          
          // Wait for search to complete
          await page.waitForTimeout(1000)
          
          // Check that no script executed
          const alertFired = await page.evaluate(() => {
            return window.document.body.innerHTML.includes('alert(') ||
                   window.document.body.innerHTML.includes('<script>')
          })

          expect(alertFired, `XSS in search: ${payload}`).toBe(false)
        }
      }
    })

    test('should prevent stored XSS in persistent data', async ({ page, request }) => {
      // Create data with potential XSS
      const maliciousProject = {
        name: '<script>document.title="STORED_XSS"</script>',
        code: `XSS_${Date.now()}`,
        description: '<img src=x onerror=document.body.style.background="red">',
        budget: 100000,
        bonusPool: 50000,
        profitTarget: 200000
      }

      const createResult = await utils.testApiEndpoint('POST', '/api/projects', {
        token: adminToken,
        data: maliciousProject
      })

      if (createResult.status === 201) {
        const projectId = createResult.data.data.id

        try {
          // Navigate to projects page and verify no XSS execution
          await utils.loginAs('admin')
          await page.goto('/projects')
          await page.waitForLoadState('networkidle')

          // Check that title hasn't been changed by XSS
          const title = await page.title()
          expect(title).not.toBe('STORED_XSS')

          // Check that background hasn't been changed
          const bgColor = await page.evaluate(() => 
            window.getComputedStyle(document.body).backgroundColor
          )
          expect(bgColor).not.toBe('red')
          expect(bgColor).not.toContain('rgb(255, 0, 0)')

        } finally {
          // Clean up
          await utils.testApiEndpoint('DELETE', `/api/projects/${projectId}`, {
            token: adminToken
          }).catch(() => {})
        }
      }
    })
  })

  test.describe('SQL/NoSQL Injection Protection', () => {
    test('should prevent SQL injection in search queries', async ({ request }) => {
      const sqlInjectionPayloads = [
        "'; DROP TABLE employees; --",
        "' OR '1'='1",
        "' UNION SELECT * FROM users --",
        "'; INSERT INTO employees VALUES ('hacker', 'admin'); --",
        "' OR 1=1 --",
        "admin'--",
        "' OR 'x'='x",
        "'; EXEC sp_configure 'show advanced options', 1--"
      ]

      for (const payload of sqlInjectionPayloads) {
        const result = await utils.testApiEndpoint('GET', 
          `/api/employees?search=${encodeURIComponent(payload)}`,
          { token: adminToken }
        )

        // Should return normal response (not error or unexpected data)
        expect(result.status).toBe(200)
        
        // Should not return all employees (which would indicate successful injection)
        if (result.data.data.list) {
          // If injection worked, we'd likely get all employees
          // Normal search for garbage should return few/no results
          expect(result.data.data.total).toBeLessThan(100) // Reasonable limit
        }
      }
    })

    test('should prevent NoSQL injection in NeDB queries', async ({ request }) => {
      const nosqlInjectionPayloads = [
        '{"$ne": null}',
        '{"$regex": ".*"}',
        '{"$where": "function() { return true; }"}',
        '{"$gt": ""}',
        '{"$or": [{"name": "admin"}, {"name": "user"}]}',
        '{"name": {"$exists": true}}',
        '{"$expr": {"$gt": [{"$strLenCP": "$name"}, 0]}}'
      ]

      for (const payload of nosqlInjectionPayloads) {
        const result = await utils.testApiEndpoint('GET',
          `/api/departments?filter=${encodeURIComponent(payload)}`,
          { token: adminToken }
        )

        // Should either work normally or return proper error (not expose data)
        expect([200, 400, 422]).toContain(result.status)
        
        if (result.status === 200) {
          // Should return reasonable amount of data, not everything
          const departments = result.data.data.list || result.data.data
          if (Array.isArray(departments)) {
            expect(departments.length).toBeLessThan(50) // Reasonable limit
          }
        }
      }
    })

    test('should validate and sanitize input parameters', async ({ request }) => {
      const dangerousInputs = [
        { field: 'employeeNo', value: "'; DROP TABLE users; --" },
        { field: 'name', value: '"><script>alert("injection")</script>' },
        { field: 'email', value: 'admin@example.com"; DELETE FROM employees WHERE 1=1; --' },
        { field: 'departmentId', value: '1 OR 1=1' }
      ]

      for (const { field, value } of dangerousInputs) {
        const employeeData = {
          employeeNo: `SAFE_${Date.now()}`,
          name: '安全测试员工',
          departmentId: 1,
          positionId: 1,
          annualSalary: 100000,
          entryDate: '2024-01-01',
          [field]: value // Override with dangerous value
        }

        const result = await utils.testApiEndpoint('POST', '/api/employees', {
          token: adminToken,
          data: employeeData
        })

        // Should either sanitize input and create, or reject with validation error
        if (result.status === 201) {
          const createdEmployee = result.data.data
          
          // Verify the dangerous input was sanitized
          const fieldValue = createdEmployee[field]
          if (typeof fieldValue === 'string') {
            expect(fieldValue).not.toContain('DROP TABLE')
            expect(fieldValue).not.toContain('<script>')
            expect(fieldValue).not.toContain('DELETE FROM')
          }

          // Clean up
          await utils.testApiEndpoint('DELETE', `/api/employees/${createdEmployee.id}`, {
            token: adminToken
          }).catch(() => {})
        } else {
          // Should be validation error, not server error
          expect(result.status).toBe(400)
          expect(result.data.message).toContain('验证失败')
        }
      }
    })
  })

  test.describe('Authentication & Authorization Bypass', () => {
    test('should prevent privilege escalation', async ({ request }) => {
      // Employee tries to access admin functionality
      const adminEndpoints = [
        { method: 'GET' as const, url: '/api/users' },
        { method: 'POST' as const, url: '/api/users', data: { username: 'hacker', password: 'hack' } },
        { method: 'DELETE' as const, url: '/api/users/1' },
        { method: 'GET' as const, url: '/api/system/config' },
        { method: 'POST' as const, url: '/api/roles', data: { name: 'admin', permissions: ['*'] } }
      ]

      for (const { method, url, data } of adminEndpoints) {
        const result = await utils.testApiEndpoint(method, url, {
          token: employeeToken,
          data,
          expectedStatus: 403
        })

        expect(result.status, `Privilege escalation possible at ${method} ${url}`).toBe(403)
        expect(result.data.message).toMatch(/(权限不足|Access denied|Forbidden)/)
      }
    })

    test('should prevent JWT token manipulation', async ({ request }) => {
      const validToken = adminToken
      
      // Try to manipulate token parts
      const tokenParts = validToken.split('.')
      
      if (tokenParts.length === 3) {
        const [header, payload, signature] = tokenParts

        const manipulatedTokens = [
          // Change payload
          header + '.' + btoa(JSON.stringify({ userId: 999, role: 'super_admin' })) + '.' + signature,
          
          // Invalid signature
          header + '.' + payload + '.fake_signature',
          
          // Malformed tokens
          'invalid.token.format',
          'not-a-jwt-token',
          '',
          'null'
        ]

        for (const manipulatedToken of manipulatedTokens) {
          const result = await utils.testApiEndpoint('GET', '/api/users', {
            token: manipulatedToken,
            expectedStatus: 401
          })

          expect(result.status, `Manipulated token accepted: ${manipulatedToken.substring(0, 20)}...`)
            .toBe(401)
        }
      }
    })

    test('should enforce session timeout', async ({ page }) => {
      await utils.loginAs('admin')
      
      // Simulate expired session by manipulating token
      await page.evaluate(() => {
        const token = localStorage.getItem('token')
        if (token) {
          const parts = token.split('.')
          if (parts.length === 3) {
            const payload = JSON.parse(atob(parts[1]))
            payload.exp = Math.floor(Date.now() / 1000) - 3600 // Expired 1 hour ago
            parts[1] = btoa(JSON.stringify(payload))
            localStorage.setItem('token', parts.join('.'))
          }
        }
      })

      // Try to access protected page
      await page.goto('/employees')
      
      // Should redirect to login
      await expect(page).toHaveURL(/login/, { timeout: 10000 })
    })

    test('should prevent CSRF attacks', async ({ request, page }) => {
      // Test that state-changing operations require proper authentication
      // and potentially CSRF tokens
      
      await utils.loginAs('admin')
      
      // Get current CSRF token if present
      const csrfToken = await page.evaluate(() => {
        return document.querySelector('meta[name="csrf-token"]')?.getAttribute('content') ||
               localStorage.getItem('csrf-token') ||
               sessionStorage.getItem('csrf-token')
      })

      // Try to make request without CSRF token (if system uses them)
      const stateChangingOperations = [
        { method: 'POST' as const, url: '/api/employees', data: { name: 'CSRF Test' } },
        { method: 'PUT' as const, url: '/api/employees/1', data: { name: 'CSRF Update' } },
        { method: 'DELETE' as const, url: '/api/employees/999' }
      ]

      for (const { method, url, data } of stateChangingOperations) {
        // Make request without proper CSRF protection
        const headers: Record<string, string> = {
          'Authorization': `Bearer ${adminToken}`,
          'Content-Type': 'application/json'
        }

        // Don't include CSRF token to test if it's required
        if (utils.apiContext) {
          const response = await utils.apiContext.request(url, {
            method,
            headers,
            data: JSON.stringify(data)
          })

          // System should either require CSRF token (403/422) or have other CSRF protection
          // If no CSRF protection, operation should still validate properly
          expect([200, 201, 400, 401, 403, 422]).toContain(response.status())
        }
      }
    })
  })

  test.describe('Data Protection & Privacy', () => {
    test('should mask sensitive data in API responses', async ({ request }) => {
      // Get user data and verify sensitive fields are masked
      const result = await utils.testApiEndpoint('GET', '/api/users', {
        token: adminToken
      })

      if (result.status === 200) {
        const users = result.data.data.list || result.data.data
        
        if (Array.isArray(users) && users.length > 0) {
          users.forEach(user => {
            // Password should never be present in response
            expect(user.password).toBeUndefined()
            expect(user.passwordHash).toBeUndefined()
            
            // Other sensitive fields should be masked if present
            if (user.email) {
              // Email might be partially masked like: j***@example.com
              if (user.email.includes('*')) {
                expect(user.email).toMatch(/^[^*]+\*+.*@.*/)
              }
            }
          })
        }
      }
    })

    test('should prevent information disclosure through error messages', async ({ request }) => {
      // Test that error messages don't reveal system information
      const informationLeakTests = [
        { url: '/api/employees/999999999', expectedStatus: 404 },
        { url: '/api/nonexistent-endpoint', expectedStatus: 404 },
        { 
          url: '/api/employees', 
          method: 'POST' as const,
          data: { invalid: 'data' }, 
          expectedStatus: 400 
        }
      ]

      for (const { url, method = 'GET', data, expectedStatus } of informationLeakTests) {
        const result = await utils.testApiEndpoint(method, url, {
          token: adminToken,
          data,
          expectedStatus
        })

        expect(result.status).toBe(expectedStatus)

        if (result.data.message) {
          const errorMessage = result.data.message.toLowerCase()
          
          // Should not reveal system internals
          expect(errorMessage).not.toContain('database')
          expect(errorMessage).not.toContain('sql')
          expect(errorMessage).not.toContain('mongodb')
          expect(errorMessage).not.toContain('nedb')
          expect(errorMessage).not.toContain('stack trace')
          expect(errorMessage).not.toContain('file path')
          expect(errorMessage).not.toContain('directory')
          expect(errorMessage).not.toContain('server error')
          expect(errorMessage).not.toContain('internal error')
        }
      }
    })

    test('should implement proper access logging', async ({ request }) => {
      // Test that security-relevant events are logged
      const securityEvents = [
        // Failed login attempts
        {
          endpoint: '/api/auth/login',
          method: 'POST' as const,
          data: { username: 'invalid', password: 'invalid' },
          expectedStatus: 401
        },
        // Unauthorized access attempts
        {
          endpoint: '/api/users',
          method: 'GET' as const,
          token: 'invalid-token',
          expectedStatus: 401
        }
      ]

      for (const { endpoint, method, data, token, expectedStatus } of securityEvents) {
        const result = await utils.testApiEndpoint(method, endpoint, {
          token: token || employeeToken,
          data,
          expectedStatus
        })

        expect(result.status).toBe(expectedStatus)
        
        // Verify that response includes tracking info (request ID, etc.)
        // This helps with security monitoring and incident response
        if (result.headers) {
          const responseId = result.headers['x-request-id'] || 
                           result.headers['x-correlation-id'] ||
                           result.headers['request-id']
          
          // Should have some form of request tracking
          // (Not all systems implement this, so we won't assert)
        }
      }
    })

    test('should prevent data exfiltration through export functions', async ({ request }) => {
      // Test that data export functions have proper access controls
      const exportEndpoints = [
        '/api/employees/export',
        '/api/departments/export', 
        '/api/reports/export',
        '/api/data/export'
      ]

      for (const endpoint of exportEndpoints) {
        // Employee shouldn't be able to export sensitive data
        const employeeResult = await utils.testApiEndpoint('GET', endpoint, {
          token: employeeToken,
          expectedStatus: 403
        })

        expect(employeeResult.status, `Employee can export data from ${endpoint}`).toBe(403)

        // Admin should be able to export (if endpoint exists)
        const adminResult = await utils.testApiEndpoint('GET', endpoint, {
          token: adminToken
        })

        // Either works (200) or endpoint doesn't exist (404)
        expect([200, 404]).toContain(adminResult.status)
      }
    })
  })

  test.describe('File Upload Security', () => {
    test('should validate file types and sizes', async ({ page }) => {
      await utils.loginAs('admin')
      
      // Look for file upload functionality
      await page.goto('/employees')
      await page.waitForLoadState('networkidle')

      const fileInputs = await page.locator('input[type="file"]').count()
      
      if (fileInputs > 0) {
        // Test malicious file uploads
        const maliciousFiles = [
          { name: 'test.exe', content: 'MZ\x90\x00' }, // Executable
          { name: 'test.php', content: '<?php phpinfo(); ?>' }, // PHP script
          { name: 'test.js', content: 'alert("XSS");' }, // JavaScript
          { name: 'huge_file.txt', content: 'x'.repeat(10 * 1024 * 1024) } // 10MB file
        ]

        for (const { name, content } of maliciousFiles) {
          // Create temporary file
          const file = new File([content], name, { type: 'application/octet-stream' })
          
          try {
            // Attempt upload
            const fileInput = page.locator('input[type="file"]').first()
            await fileInput.setInputFiles({
              name,
              mimeType: 'application/octet-stream',
              buffer: Buffer.from(content)
            })

            // Should show error or reject file
            const errorMessage = await page.locator('.el-message--error').textContent()
              .catch(() => null)

            // System should reject dangerous files
            if (!errorMessage) {
              // If no immediate error, check if upload was actually rejected
              // This depends on implementation - might be client-side or server-side validation
            }
          } catch (error) {
            // Upload rejection is expected for dangerous files
          }
        }
      }
    })

    test('should prevent path traversal in file operations', async ({ request }) => {
      const pathTraversalAttempts = [
        '../../../etc/passwd',
        '..\\..\\..\\windows\\system32\\config\\sam',
        '../../config/database.js',
        '../.env',
        '../../package.json'
      ]

      for (const path of pathTraversalAttempts) {
        // Test file download/access endpoints
        const fileEndpoints = [
          `/api/files/${encodeURIComponent(path)}`,
          `/api/download/${encodeURIComponent(path)}`,
          `/api/export/${encodeURIComponent(path)}`
        ]

        for (const endpoint of fileEndpoints) {
          const result = await utils.testApiEndpoint('GET', endpoint, {
            token: adminToken
          })

          // Should not return sensitive files
          expect([400, 403, 404]).toContain(result.status)
          
          if (result.status === 200 && result.data) {
            // If somehow it returns data, it shouldn't be system files
            const content = JSON.stringify(result.data).toLowerCase()
            expect(content).not.toContain('password')
            expect(content).not.toContain('root:')
            expect(content).not.toContain('database_url')
            expect(content).not.toContain('secret')
          }
        }
      }
    })
  })

  test.describe('Rate Limiting & DoS Protection', () => {
    test('should implement rate limiting on sensitive endpoints', async ({ request }) => {
      const rateLimitedEndpoints = [
        '/api/auth/login',
        '/api/auth/register',
        '/api/auth/forgot-password'
      ]

      for (const endpoint of rateLimitedEndpoints) {
        const rapidRequests = []
        
        // Make many rapid requests
        for (let i = 0; i < 10; i++) {
          rapidRequests.push(
            utils.testApiEndpoint('POST', endpoint, {
              data: { username: `test${i}`, password: 'test123' }
            })
          )
        }

        const results = await Promise.all(rapidRequests)
        
        // Should have some rate limiting (429 responses)
        const rateLimitedCount = results.filter(r => r.status === 429).length
        
        // At least some requests should be rate limited
        if (rateLimitedCount === 0) {
          // If no rate limiting, at least check that server handled the load
          const serverErrors = results.filter(r => r.status >= 500).length
          expect(serverErrors).toBe(0) // No server crashes
        }
      }
    })

    test('should handle resource exhaustion attempts', async ({ request }) => {
      // Test large payload handling
      const largePayload = {
        name: 'A'.repeat(100000), // 100KB name
        description: 'B'.repeat(500000), // 500KB description
        metadata: 'C'.repeat(1000000) // 1MB metadata
      }

      const result = await utils.testApiEndpoint('POST', '/api/employees', {
        token: adminToken,
        data: largePayload,
        timeout: 15000
      })

      // Should either handle gracefully or reject with proper error
      expect([201, 400, 413, 422]).toContain(result.status)
      
      if (result.status >= 500) {
        // Server errors indicate potential DoS vulnerability
        console.warn('Large payload caused server error - potential DoS vulnerability')
      }

      if (result.status === 201) {
        // If created, clean up
        await utils.testApiEndpoint('DELETE', `/api/employees/${result.data.data.id}`, {
          token: adminToken
        }).catch(() => {})
      }
    })

    test('should prevent slowloris-style attacks', async ({ request }) => {
      // Test slow request handling
      const slowRequests = []
      
      for (let i = 0; i < 5; i++) {
        slowRequests.push(
          utils.testApiEndpoint('GET', '/api/employees', {
            token: adminToken,
            timeout: 30000 // Long timeout
          })
        )
      }

      const startTime = performance.now()
      const results = await Promise.all(slowRequests)
      const totalTime = performance.now() - startTime

      // All requests should complete
      results.forEach(result => {
        expect(result.status).toBe(200)
      })

      // Should not take excessively long
      expect(totalTime).toBeLessThan(60000) // Under 1 minute total
    })
  })

  test.afterAll(async () => {
    // Clean up any test data created during security tests
    if (adminToken) {
      await utils.cleanupTestData(adminToken)
    }
  })
})